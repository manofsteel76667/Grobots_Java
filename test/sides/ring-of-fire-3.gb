#side Ring of Fire 3
#author Devon
12 November 2002

Autotrophs with blaster-using defenders that avoid friendly fire.
This was a silly decorative side at first, but has become semi-serious.

#color f60

#type core
#color 0c9

(20030716) Slightly smaller.

#hardware
  processor 2
  energy 5 0
  solar-cells .4
  constructor .4
  armor 30
#code
constructor-max-rate constructor-rate!
do
  constructor-type nif
    0 2 random-int 1 max constructor-type!
  then
forever

#type ring
#color 000

(20030602) Uses vread/vwrite.
           Separate fighting mode; keep distance from enemies.
(20030716) Friendly fire avoidance.
           Don't give up fighting when out of energy.

#hardware
  processor 25
  radio read write
  robot-sensor 16 8
  
  blaster 20 16 20
  armor 200
  repair-rate .04
  
  engine .03
  energy 100 0
  solar-cells .15
  
#code

;mem:
;2,3: home

#vector post
#var dir
#const fighting-distance 14

pick-post:
  1 type-population sqrt 4 + 2 type-population max
  dir
  polar-to-rect 2 vread v+ post!
return

#start
  0 world-width random 0 world-height random position v- angle dir!
2 read if
  2 vread 5 vs* position v+ 6 vs/
else
  position
then 2 vwrite

idle:
do
  pick-post
  post seek-location
  time robot-sensor-time 45 + >= if energy blaster-firing-cost > and-if
    fire-robot-sensor sync
    robot-found if
      record-target^
      shoot^
      fighting& jump
    then
  then
  energy 25 > max-repair-rate 0 ifev repair-rate!
  sync
forever

#vector target-position
#vector target-velocity
#var target-distance

fighting:
do
  position target-position v- unitize fighting-distance vs* target-position v+
    target-velocity seek-moving-location
  time robot-sensor-time blaster-reload-time + >= if
    fire-robot-sensor sync
    robot-found idle& nifg
    record-target^
    energy blaster-firing-cost > shoot& ifc
  then
  energy 25 > max-repair-rate 0 ifev repair-rate!
forever

record-target:
  robot-position target-position!
  robot-velocity target-velocity!
  robot-distance target-distance!
return

#var blast-direction
#vector blast-velocity

shoot:
  target-velocity velocity v- 2dup target-distance blaster-speed / vs* target-position v+
  position dist blaster-speed / vs* target-position v+
  position v- angle blast-direction!
  velocity blaster-speed blast-direction polar-to-rect v+ blast-velocity!
;look for friends
  0 robot-sensor-sees-enemies!
  1 robot-sensor-sees-friends!
  target-distance 2 / robot-sensor-focus-distance!
  blast-direction robot-sensor-focus-direction!
  fire-robot-sensor sync
  1 robot-sensor-sees-enemies!
  0 robot-sensor-sees-friends!
  0 robot-sensor-focus-distance!
;anybody in the way?
  robot-found if
    do
      robot-position position v- 2dup
      blast-velocity robot-velocity v- unitize dot dup radius > swap target-distance < and
      rrot blast-velocity robot-velocity v- unitize cross abs robot-radius .2 + < and ifr
    next-robot while-loop
  then
;shoot
  blast-direction fire-blaster
return


#end
